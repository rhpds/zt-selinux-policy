== Check for the AVC denials

Our service app is up and running, SELinux is in enforcing mode, but in
the policy is hard coded to allow our application to run in Permissive
mode. The system does not stop _testapp_ from accessing any requested
objects, but it logs all the SELinux policy violations in
/var/log/audit/audit.log

To start modifying our policy to allow the actions required by our
application we will look in the audit log for messages of type AVC that
happened today. We use the *ausearch* command.

[source,bash]
----
sudo ausearch --message AVC --start today
----

Wow! There are quite a few denials!

Let’s just focus in in the first AVC message. To do this we can use the
filter from the ausearch command to retrieve just one entry, the first
one, from the desired timeframe. The ausearch command takes a time in
format _hh:mm:ss_, or reference (today | recent) for the _–start_
argument.

Here are some examples:

[source,bash]
----
# The first AVC today
ausearch --message AVC --just-one --start today
----

____
____

This returns since we have never run our testapp before and our system
was clean earlier, this shows us the first AVC generated by testapp.

We see that testapp was denied "`write open`", "`create`", and
"`add_name`" on "`/run/testapp.pid`". So our system is secure enough
that our basic policy is not even allowing the application to make a pid
file on the tmpfs. That’s pretty secure, however, it seems reasonable
that we should allow this. Our app should be able to create a pid file
and other temp files as necessary.

How do we specify this?

Our policy interacts with the SELinux system through a series of
interfaces and allow statements. For interfaces, we pass our context
type information to the interface and a macro in the security server
implements a series of rules to allow a particular behaviour. This makes
creating policy easier. Allow statements can be more specific, basically
stating:

_allow *domainX* to perform *actionY* in *contextZ*_

or something similar.

There is a command called *audit2allow* and an alias *audit2why* (==
audit2allow -w) that can give us information about why an AVC occured.
It is also able to suggest policy changes we might make to allow the
behaviour identified by the AVC denial. Let’s take a look at the output
of audit2allow for our first AVC. Adding the _-R_ switch asks the
program to return suggestions for the policy change that makes use of
the currently installed interface macros.

____
IMPORTANT: This utility does a best fit analysis. The macros that are
referenced may be a less restrictive than you require. Using the -N or
using no switches will produce traditional allow statements only. See
the audit2allow manpage
____

[source,bash]
----
ausearch --message AVC --start today --just-one | audit2allow -R
----

Here you see one allow statement and one interface. The allow statement
says, “Any process labelled _testapp_t_ can access a _file_ labelled
_var_run_t_ for the actions _create, open, write_. The interface appears
to be for creating policy that allows read and write access to
directories used for pid files. It is being passed our testapp_t type as
a parameter.

*Where to find interface information*

The interfaces are really macros that implement allow statments and
additional macros to more easily build policy and promote reuse. The
interface definitions are provided as part of the _selinux-policy-devel_
package. This should be installed on your system already. The files for
the definitions are stored in _/usr/share/selinux/devel/include_. Like
our own policy interfaces, they are stored in files with the _*.if_
extention. The command audit2allow _-R_ looks at the interfaces that
have been built from these files to find matches. We can also search
through the files ourselves to find interfaces that we want to add to
our policy. For now let’s use the recommendation from audit2allow and
modify the testapp.te file. Open the policy with the vim editor.

[source,bash]
----
vim /root/selinuxlab/policy/testapp.te
----

It should look like the following.

Use the editor to add the audit2allow recommendations to the end of the
policy file under the testapp local policy section

Traditionally, for readability and searching, we try to add the elements
in alphabetical order. The resulting file should look like this.

OK. Ensure your file is saved and run the testapp.sh script again. To
save the file, press escape, then type :wq! and press enter.

[source,bash]
----
/root/selinuxlab/policy/testapp.sh
----

You should see the successful compilation of your policy. The output
below is truncated.

____
*IMPORTANT TRICK* We want to find only the AVCs that are created during
the latest run of testapp. So we can modify our command a bit to focus
just on the current execution. Grab the date just before we start using
*date +%T*. Restart the testapp service. Now use the output of the
command in your ausearch command. See below.
____

Get all the AVCs since we restarted the app

[source,bash]
----
# All AVCs from the last run
TIME=`date +%T`;export TIME; sudo systemctl restart testapp; sudo ausearch --message AVC --start $TIME
----

Get only the first AVC since we restarted the app

[source,bash]
----
# just the first AVC from the last run
TIME=`date +%T`;export TIME; sudo systemctl restart testapp; sudo ausearch --message AVC --just-one --start $TIME
----

Excellent! The previous AVC is gone!

We still have more though. Let’s dig into the interface files to find
the answer to this next one.

If we look at the AVC, we can see that the testapp process is being
denied open and read on /proc/meminfo. We need to allow our application
to look at system state information in /proc. Let’s use find to look for
interface definition files that contain /proc and something about
'`system state information`'.

[source,bash]
----
cd /usr/share/selinux/devel/include
find . -type f -name "*.if" -exec grep -H '/proc' {} \; | grep "system state information"
----

Wow, lucky guess ;-)

Lets look in the file and find the "`system state information`" comment.
You can use the _less_ command and then _/ read system state
information_. We find this interface definition.

[source,bash]
----
less /usr/share/selinux/devel/include/kernel/kernel.if
----

The interface defined at the bottom of the file is called
*kernel_read_system_state* and it takes one required parameter that is
the context of the process that we want to be a
_kernel_system_state_reader_. That means we pass *testapp_t* to the
interface. Edit the testapp.te file with vim and add a line in
alphabetical order that calls *kernel_read_system_state(testapp_t)*

When you are done, the end of the file should look like this.

OK. Ensure your file is saved and run the testapp.sh script again. Run
*date +%T* again to get a new time. Now, restart the testapp service.
And the moment of truth, check to see if the AVC is still there.

[source,bash]
----
TIME=`date +%T`;export TIME; sudo systemctl restart testapp; sudo ausearch --message AVC --start $TIME | grep meminfo | wc -l;
----

Zero is good.

2 AVCs down and a few more to go. Let’s look at some network AVCs next.
On to the next challenge!
